"""
هدف این فایل:
- پیاده‌سازی منطق تصمیم‌گیری ML-Assisted TPC برای LoRaWAN
- ورودی: SNR پیش‌بینی‌شده توسط مدل ML (snr_pred)
- خروجی: یک تصمیم شامل (SF, TP) و Margin نهایی (Me)

ایده اصلی:
- ابتدا با SNR پیش‌بینی‌شده یک Margin تعریف می‌کنیم:
    Me = SNR_eff - SNR_limit(SF) - LinkMargin
- اگر Me منفی باشد یعنی لینک از نظر شرط ما «ایمن نیست» و باید Robustness را افزایش دهیم
- اگر Me مثبت باشد یعنی لینک حاشیه دارد و می‌توان برای کاهش انرژی، SF/TP را کم کرد

توجه:
- این نسخه «presentation-friendly» است: ساده، قابل توضیح و قابل پیاده‌سازی سریع
- هدف شبیه‌سازی دقیق فیزیک لینک نیست؛ هدف نشان دادن روند تصمیم‌گیری است
"""

from __future__ import annotations

from dataclasses import dataclass
from . import config


# -----------------------------------------------------------------------------
# خروجی استاندارد تصمیم TPC
# -----------------------------------------------------------------------------
@dataclass
class TPCDecision:
    """
    ساختار خروجی تصمیم TPC.

    sf: Spreading Factor انتخابی (معمولاً 7..12)
    tp: توان ارسال انتخابی (dBm)
    me: margin نهایی پس از اعمال تصمیم (dB)
    """
    sf: int
    tp: float
    me: float


def snr_limit(sf: int) -> float:
    """
    دریافت آستانه SNR_limit مربوط به یک SF مشخص.

    این آستانه‌ها از config.SNR_LIMIT_BY_SF می‌آیند و معمولاً برای BW=125kHz رایج هستند.
    """
    return config.SNR_LIMIT_BY_SF[int(sf)]


def decide_tpc(
    snr_pred: float,
    sf_start: int | None = None,
    tp_start: float | None = None
) -> TPCDecision:
    """
    تصمیم‌گیری TPC بر اساس SNR پیش‌بینی‌شده و مفهوم margin.

    تعریف margin:
      Me = SNR_eff - SNR_limit(SF) - LM

    که در آن:
    - SNR_eff: SNR موثر (در این پیاده‌سازی به صورت ساده، اثر تغییر TP را خطی در نظر می‌گیریم)
    - SNR_limit(SF): آستانه مورد نیاز برای SF انتخابی
    - LM: Link Margin (حاشیه اطمینان) از config.LINK_MARGIN_DB

    استراتژی تصمیم‌گیری (ساده و قابل ارائه):
    1) اگر Me < 0  (لینک ضعیف است):
       - ابتدا SF را افزایش می‌دهیم تا Robustness بیشتر شود (تا SF_MAX)
       - اگر هنوز Me منفی بود، TP را افزایش می‌دهیم تا SNR_eff بهتر شود (تا TP_MAX)

    2) اگر Me >= 0 (حاشیه داریم):
       - ابتدا SF را کاهش می‌دهیم تا Time-on-Air کم شود (و انرژی کمتر شود)،
         تا جایی که هنوز margin غیرمنفی بماند
       - سپس TP را کاهش می‌دهیم تا توان ارسال کمتر و انرژی کمتر شود،
         تا جایی که هنوز margin غیرمنفی بماند

    خروجی:
    - یک TPCDecision شامل sf و tp نهایی و margin نهایی
    """

    # -------------------------------------------------------------------------
    # مقدار شروع SF و TP
    # اگر ورودی داده نشده باشد از baseline استفاده می‌کنیم (برای تکرارپذیری و مقایسه)
    # -------------------------------------------------------------------------
    sf = int(sf_start) if sf_start is not None else config.BASELINE_SF
    tp = float(tp_start) if tp_start is not None else float(config.BASELINE_TP)

    # -------------------------------------------------------------------------
    # تابع داخلی برای محاسبه margin برای یک (SF, TP) پیشنهادی
    #
    # نکته مهم:
    # در این پیاده‌سازی "اثر TP" به شکل بسیار ساده مدل شده:
    #   snr_eff = snr_pred + (tp - baseline_tp)
    # یعنی هر 1 dBm افزایش TP، 1 dB به SNR موثر اضافه می‌کند.
    # این یک تقریب برای ارائه است (نه مدل دقیق کانال).
    # -------------------------------------------------------------------------
    def me(sf_val: int, tp_val: float) -> float:
        snr_eff = snr_pred + (tp_val - config.BASELINE_TP)
        return snr_eff - snr_limit(sf_val) - config.LINK_MARGIN_DB

    # =========================================================================
    # فاز A) اگر margin منفی است: Robustness را بالا می‌بریم
    # =========================================================================

    # -------------------------------------------------------------------------
    # A1) تا وقتی margin منفی است و SF هنوز به SF_MAX نرسیده:
    #     SF را یک واحد افزایش می‌دهیم
    # منطق: افزایش SF معمولاً حساسیت گیرنده را بهتر می‌کند و لینک robustتر می‌شود
    # -------------------------------------------------------------------------
    while me(sf, tp) < 0 and sf < config.SF_MAX:
        sf += 1

    # -------------------------------------------------------------------------
    # A2) اگر هنوز margin منفی است، TP را افزایش می‌دهیم تا SNR_eff بیشتر شود
    #     تا رسیدن به TP_MAX
    # -------------------------------------------------------------------------
    while me(sf, tp) < 0 and tp < config.TP_MAX:
        tp += 1.0

    # =========================================================================
    # فاز B) اگر margin غیرمنفی است: انرژی را کاهش می‌دهیم (بهینه‌سازی)
    # =========================================================================

    # -------------------------------------------------------------------------
    # B1) ابتدا SF را پایین می‌آوریم، تا جایی که هنوز margin >= 0 بماند
    # منطق: کاهش SF معمولاً Time-on-Air را کم می‌کند و انرژی کمتر می‌شود
    # شرط: اگر با SF کمتر هم margin غیرمنفی بود، پس کاهش SF مجاز است
    # -------------------------------------------------------------------------
    while sf > config.SF_MIN and me(sf - 1, tp) >= 0:
        sf -= 1

    # -------------------------------------------------------------------------
    # B2) سپس TP را پایین می‌آوریم، تا جایی که هنوز margin >= 0 بماند
    # منطق: توان کمتر => انرژی کمتر
    # -------------------------------------------------------------------------
    while tp > config.TP_MIN and me(sf, tp - 1.0) >= 0:
        tp -= 1.0

    # -------------------------------------------------------------------------
    # خروجی نهایی: SF/TP و margin نهایی
    # -------------------------------------------------------------------------
    return TPCDecision(sf=sf, tp=tp, me=float(me(sf, tp)))
